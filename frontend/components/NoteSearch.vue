<template>
  <div class="w-full max-w-2xl mx-auto">
    <div class="mb-4">
      <label for="noteSearch" class="form-label sr-only">Search Notes</label>
      <input
        id="noteSearch"
        v-model="searchQuery"
        type="search"
        placeholder="Search clinical notes..."
        class="form-input" 
        @input="performSearch"
      />
    </div>

    <div v-if="isLoading" class="text-center text-soft dark:text-dark-soft">
      Searching...
    </div>
    <ul v-else-if="results.length > 0" class="space-y-4">
      <li v-for="note in results" :key="note.id">
        <Card class="p-4">
          <p class="text-sm text-text dark:text-dark-text mb-1 whitespace-pre-wrap" v-html="formatHighlight(note.content, note._formatted?.content)"></p>
          <p v-if="note.summary" class="text-xs text-soft dark:text-dark-soft italic border-t border-soft/50 dark:border-dark-soft/50 pt-1 mt-1" v-html="formatHighlight(note.summary, note._formatted?.summary)"></p>
          <p class="text-xs text-gray-400 dark:text-gray-500 mt-1">
             Note ID: {{ note.id }} | Patient ID: {{ note.patient_id }}
           </p>
        </Card>
      </li>
    </ul>
    <div v-else-if="searchQuery && !isLoading" class="text-center text-soft dark:text-dark-soft">
      No notes found matching "{{ searchQuery }}".
    </div>
    <div v-else class="text-center text-soft dark:text-dark-soft">
        Enter a term above to search notes.
    </div>

  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'
import type { Note } from '~/types/note'
import Card from '~/components/Card.vue'
import { Meilisearch, type Hit, type SearchResponse } from 'meilisearch' // Import Meilisearch class/types

// Type for Meilisearch hit, including the optional _formatted field
interface NoteHit extends Note {
    _formatted?: Partial<Note>; // Meilisearch adds highlights here
}

const searchQuery = ref('')
const results = ref<NoteHit[]>([])
const isLoading = ref(false)
const debounceTimer = ref<NodeJS.Timeout | null>(null);

// Get Nuxt app instance
const nuxtApp = useNuxtApp();
// Assign the potentially null Meilisearch client to a local variable
const meiliClient = nuxtApp.$meili as Meilisearch | null;

// Debounced search function
const performSearch = () => {
  if (debounceTimer.value) {
    clearTimeout(debounceTimer.value);
  }

  debounceTimer.value = setTimeout(async () => {
    if (!meiliClient) {
        console.error("Meilisearch client is not available or failed to initialize.");
        isLoading.value = false;
        results.value = [];
        return;
    }

    const query = searchQuery.value.trim();
    if (!query) {
      results.value = [];
      isLoading.value = false;
      return;
    }

    isLoading.value = true;
    try {
      const index = meiliClient.index('notes');
      const searchResult: SearchResponse<NoteHit> = await index.search<NoteHit>(query, {
         attributesToRetrieve: ['id', 'patient_id', 'content', 'summary'],
         attributesToHighlight: ['content', 'summary'],
         highlightPreTag: '<mark class=\"bg-accent dark:bg-dark-accent text-white px-1 rounded\">',
         highlightPostTag: '</mark>',
      });

      console.log("Meilisearch results:", searchResult);
      results.value = searchResult.hits;

    } catch (error) {
      console.error('Error searching notes:', error);
      results.value = [];
    } finally {
      isLoading.value = false;
    }
  }, 300);
};

// Helper function to display highlighted text or fallback to original
const formatHighlight = (originalText: string | undefined | null, formattedText: string | undefined | null): string => {
    // Basic sanitization: Replace potential script tags (you might need a more robust library for production)
    const safeOriginal = originalText?.replace(/<script.*?>.*?<\/script>/gi, '') || '';
    const safeFormatted = formattedText?.replace(/<script.*?>.*?<\/script>/gi, '') || '';
    return safeFormatted || safeOriginal || '';
}

</script>

<style scoped>
/* Styling for mark tags generated by Meilisearch */
:deep(mark.bg-accent) {
   padding: 0.1em 0.2em;
   border-radius: 3px;
}
</style>